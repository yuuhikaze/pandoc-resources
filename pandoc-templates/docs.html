<!doctype html>
<html
    xmlns="http://www.w3.org/1999/xhtml"
    lang="$lang$"
    xml:lang="$lang$"
    $if(dir)$
    dir="$dir$"
    $endif$
>
    <head>
        <meta charset="utf-8" />
        <meta name="generator" content="pandoc" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=yes"
        />
        $for(author-meta)$
        <meta name="author" content="$author-meta$" />
        $endfor$ $if(date-meta)$
        <meta name="dcterms.date" content="$date-meta$" />
        $endif$ $if(keywords)$
        <meta
            name="keywords"
            content="$for(keywords)$$keywords$$sep$, $endfor$"
        />
        $endif$ $if(description-meta)$
        <meta name="description" content="$description-meta$" />
        $endif$
        <title>$if(title-prefix)$$title-prefix$ – $endif$$pagetitle$</title>
        <style>
            $styles.html()$
        </style>
        $for(css)$
        <link rel="stylesheet" href="$css$" />
        $endfor$ $for(header-includes)$ $header-includes$ $endfor$
        <script
            data-external="1"
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
        ></script>
        <script>
        // Tabset functionality for pandoc-rendered markdown
        // Emulates R Markdown's {.tabset} behavior
        document.addEventListener('DOMContentLoaded', function() {
          // Find all headers with 'tabset' class (pandoc applies class to header, not section)
          document.querySelectorAll('h1.tabset, h2.tabset, h3.tabset, h4.tabset, h5.tabset, h6.tabset').forEach(function(tabsetHeader) {
            const tabLevel = parseInt(tabsetHeader.tagName[1]);
            const childHeaderTag = 'H' + (tabLevel + 1);

            // Find all child sections (tabs) - siblings until next same-level header
            const tabs = [];
            const introContent = []; // Content before first tab
            let currentTab = null;

            let sibling = tabsetHeader.nextElementSibling;
            while (sibling) {
              if (sibling.tagName === childHeaderTag) {
                // New tab starts
                if (currentTab) tabs.push(currentTab);
                currentTab = {
                  title: sibling.textContent,
                  id: sibling.id || sibling.textContent.toLowerCase().replace(/\s+/g, '-'),
                  header: sibling,
                  content: []
                };
              } else if (sibling.tagName && sibling.tagName[0] === 'H' && parseInt(sibling.tagName[1]) <= tabLevel) {
                // Hit a same-level or higher header, stop
                break;
              } else if (currentTab) {
                // Add content to current tab
                currentTab.content.push(sibling);
              } else {
                // Content before first tab (intro text)
                introContent.push(sibling);
              }
              sibling = sibling.nextElementSibling;
            }
            if (currentTab) tabs.push(currentTab);

            if (tabs.length === 0) return;

            // Create tab UI
            const tabContainer = document.createElement('div');
            tabContainer.className = 'tab-container';

            // Create tab buttons
            const tabButtons = document.createElement('div');
            tabButtons.className = 'tab-buttons';

            tabs.forEach(function(tab, index) {
              const button = document.createElement('button');
              button.className = 'tab-button' + (index === 0 ? ' active' : '');
              button.textContent = tab.title;
              button.setAttribute('data-tab', tab.id);
              button.addEventListener('click', function() {
                // Deactivate all tabs in this container
                tabContainer.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                tabContainer.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
                // Activate clicked tab
                button.classList.add('active');
                tabContainer.querySelector('.tab-panel[data-tab="' + tab.id + '"]').classList.add('active');
              });
              tabButtons.appendChild(button);
            });

            tabContainer.appendChild(tabButtons);

            // Create tab panels and move content
            tabs.forEach(function(tab, index) {
              const panel = document.createElement('div');
              panel.className = 'tab-panel' + (index === 0 ? ' active' : '');
              panel.setAttribute('data-tab', tab.id);
              tab.content.forEach(function(el) {
                panel.appendChild(el);
              });
              tabContainer.appendChild(panel);
              // Remove the original tab header
              tab.header.remove();
            });

            // Insert intro content right after tabset header, then tab container
            let insertPoint = tabsetHeader;
            introContent.forEach(function(el) {
              insertPoint.after(el);
              insertPoint = el;
            });
            insertPoint.after(tabContainer);
          });

          // Image Maximizer functionality
          // Wraps images and SVGs in containers with expand functionality
          const wrapElement = function(element) {
            // Skip if already wrapped
            if (element.parentElement && element.parentElement.classList.contains('img-wrapper')) return;

            // Get element dimensions
            const getWidth = function() {
              if (element.tagName === 'IMG') {
                return element.naturalWidth || element.width || element.clientWidth;
              } else if (element.tagName === 'SVG') {
                // For inline SVGs, try multiple methods to get width
                // 1. Check viewBox attribute for intended dimensions
                const viewBox = element.getAttribute('viewBox');
                if (viewBox) {
                  const parts = viewBox.split(/\s+|,/);
                  if (parts.length >= 4) {
                    const vbWidth = parseFloat(parts[2]);
                    if (vbWidth > 0) return vbWidth;
                  }
                }
                // 2. Check explicit width attribute
                const widthAttr = element.getAttribute('width');
                if (widthAttr && !widthAttr.includes('%')) {
                  const w = parseFloat(widthAttr);
                  if (w > 0) return w;
                }
                // 3. Try getBBox (may throw if SVG not rendered)
                try {
                  const bbox = element.getBBox ? element.getBBox() : null;
                  if (bbox && bbox.width > 0) return bbox.width;
                } catch (e) {
                  // getBBox can throw if element is not in DOM or not rendered
                }
                // 4. Fall back to client dimensions
                return element.clientWidth || element.getBoundingClientRect().width;
              }
              return 0;
            };

            // Only apply to images/SVGs wider than 200px (skip small icons)
            const width = getWidth();
            if (width < 200) return;

            // Handle parent element - <div> inside <p> is invalid HTML and breaks rendering
            const parent = element.parentNode;
            if (parent && parent.tagName === 'P') {
              // Replace <p> with <figure> to allow block-level content
              const figure = document.createElement('figure');
              figure.className = 'img-figure';
              // Move all children from <p> to <figure>
              while (parent.firstChild) {
                figure.appendChild(parent.firstChild);
              }
              parent.parentNode.replaceChild(figure, parent);
            }

            // Create wrapper
            const wrapper = document.createElement('div');
            wrapper.className = 'img-wrapper';

            // Create expand icon
            const expandIcon = document.createElement('div');
            expandIcon.className = 'img-expand-icon';
            expandIcon.innerHTML = '⤢'; // Expand arrow symbol
            expandIcon.setAttribute('title', 'Click to expand');

            // Wrap element and add icon
            element.parentNode.insertBefore(wrapper, element);
            wrapper.appendChild(element);
            wrapper.appendChild(expandIcon);

            // Add click handler to maximize
            const maximize = function() {
              // Prevent body scroll
              document.body.style.overflow = 'hidden';

              // Create overlay
              const overlay = document.createElement('div');
              overlay.className = 'img-maximized-overlay';

              // Create canvas container (handles pan/zoom transforms)
              const canvas = document.createElement('div');
              canvas.className = 'img-maximized-canvas';

              // Create content container
              const content = document.createElement('div');
              content.className = 'img-maximized-content';

              // Clone element
              const maximizedElement = element.cloneNode(true);
              maximizedElement.className = 'img-maximized';
              
              // Determine base dimensions for the image
              let baseWidth, baseHeight;
              const isSvg = element.tagName === 'IMG' && element.src && element.src.toLowerCase().endsWith('.svg');
              
              if (element.tagName === 'IMG') {
                const natWidth = element.naturalWidth || element.clientWidth;
                const natHeight = element.naturalHeight || element.clientHeight;
                
                if (natWidth && natHeight) {
                  const maxW = window.innerWidth * 0.85;
                  const maxH = window.innerHeight * 0.85;
                  const aspectRatio = natWidth / natHeight;
                  
                  if (isSvg) {
                    // Scale SVG to fit viewport initially
                    if (maxW / aspectRatio <= maxH) {
                      baseWidth = maxW;
                      baseHeight = maxW / aspectRatio;
                    } else {
                      baseHeight = maxH;
                      baseWidth = maxH * aspectRatio;
                    }
                    // Add white background for SVGs
                    maximizedElement.style.backgroundColor = '#ffffff';
                    maximizedElement.style.padding = '20px';
                    maximizedElement.style.borderRadius = '8px';
                  } else {
                    // For raster images, start at natural size or fit to viewport
                    const ratio = Math.min(maxW / natWidth, maxH / natHeight, 1);
                    baseWidth = natWidth * ratio;
                    baseHeight = natHeight * ratio;
                  }
                  
                  maximizedElement.style.width = Math.round(baseWidth) + 'px';
                  maximizedElement.style.height = Math.round(baseHeight) + 'px';
                }
              }

              // Create controls container
              const controls = document.createElement('div');
              controls.className = 'img-maximized-controls';
              
              // Zoom indicator
              const zoomIndicator = document.createElement('span');
              zoomIndicator.className = 'img-zoom-indicator';
              zoomIndicator.textContent = '100%';
              
              // Reset button
              const resetBtn = document.createElement('button');
              resetBtn.className = 'img-control-btn';
              resetBtn.innerHTML = '⟲';
              resetBtn.setAttribute('title', 'Reset zoom (R)');
              
              // Close button
              const closeBtn = document.createElement('button');
              closeBtn.className = 'img-close-btn';
              closeBtn.innerHTML = '×';
              closeBtn.setAttribute('title', 'Close (ESC)');
              
              controls.appendChild(zoomIndicator);
              controls.appendChild(resetBtn);
              controls.appendChild(closeBtn);

              // Assemble
              content.appendChild(maximizedElement);
              canvas.appendChild(content);
              overlay.appendChild(canvas);
              overlay.appendChild(controls);
              document.body.appendChild(overlay);

              // Pan and zoom state
              let scale = 1;
              let panX = 0;
              let panY = 0;
              let isDragging = false;
              let dragStartX = 0;
              let dragStartY = 0;
              let panStartX = 0;
              let panStartY = 0;
              
              const updateTransform = function() {
                content.style.transform = 'translate(' + panX + 'px, ' + panY + 'px) scale(' + scale + ')';
                zoomIndicator.textContent = Math.round(scale * 100) + '%';
              };
              
              const resetView = function() {
                scale = 1;
                panX = 0;
                panY = 0;
                updateTransform();
              };

              // Zoom with mouse wheel (zoom toward cursor position)
              canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left - rect.width / 2;
                const mouseY = e.clientY - rect.top - rect.height / 2;
                
                const prevScale = scale;
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                scale = Math.min(Math.max(scale * zoomFactor, 0.1), 20);
                
                // Adjust pan to zoom toward cursor
                const scaleChange = scale / prevScale;
                panX = mouseX - (mouseX - panX) * scaleChange;
                panY = mouseY - (mouseY - panY) * scaleChange;
                
                updateTransform();
              }, { passive: false });

              // Pan with mouse drag
              canvas.addEventListener('mousedown', function(e) {
                if (e.button !== 0) return; // Left click only
                if (e.target === closeBtn || e.target === resetBtn) return;
                
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                panStartX = panX;
                panStartY = panY;
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
              });

              document.addEventListener('mousemove', function moveHandler(e) {
                if (!isDragging) return;
                
                panX = panStartX + (e.clientX - dragStartX);
                panY = panStartY + (e.clientY - dragStartY);
                updateTransform();
              });

              document.addEventListener('mouseup', function upHandler(e) {
                if (isDragging) {
                  isDragging = false;
                  canvas.style.cursor = '';
                }
              });

              // Touch support for mobile
              let lastTouchDist = 0;
              let lastTouchX = 0;
              let lastTouchY = 0;
              
              canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                  isDragging = true;
                  dragStartX = e.touches[0].clientX;
                  dragStartY = e.touches[0].clientY;
                  panStartX = panX;
                  panStartY = panY;
                } else if (e.touches.length === 2) {
                  isDragging = false;
                  lastTouchDist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                  );
                  lastTouchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                  lastTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                }
              }, { passive: true });

              canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length === 1 && isDragging) {
                  panX = panStartX + (e.touches[0].clientX - dragStartX);
                  panY = panStartY + (e.touches[0].clientY - dragStartY);
                  updateTransform();
                  e.preventDefault();
                } else if (e.touches.length === 2) {
                  const dist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                  );
                  const touchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                  const touchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                  
                  if (lastTouchDist > 0) {
                    const prevScale = scale;
                    scale = Math.min(Math.max(scale * (dist / lastTouchDist), 0.1), 20);
                    
                    // Zoom toward pinch center
                    const rect = canvas.getBoundingClientRect();
                    const centerX = touchX - rect.left - rect.width / 2;
                    const centerY = touchY - rect.top - rect.height / 2;
                    const scaleChange = scale / prevScale;
                    panX = centerX - (centerX - panX) * scaleChange;
                    panY = centerY - (centerY - panY) * scaleChange;
                  }
                  
                  lastTouchDist = dist;
                  lastTouchX = touchX;
                  lastTouchY = touchY;
                  updateTransform();
                  e.preventDefault();
                }
              }, { passive: false });

              canvas.addEventListener('touchend', function(e) {
                isDragging = false;
                lastTouchDist = 0;
              });

              // Trigger animation
              setTimeout(function() {
                overlay.classList.add('active');
              }, 10);

              // Close handler
              const close = function() {
                overlay.classList.remove('active');
                setTimeout(function() {
                  overlay.remove();
                  document.body.style.overflow = '';
                }, 200);
              };

              // Event listeners for controls and keyboard
              closeBtn.addEventListener('click', close);
              resetBtn.addEventListener('click', resetView);
              
              overlay.addEventListener('click', function(e) {
                if (e.target === overlay || e.target === canvas) close();
              });
              
              document.addEventListener('keydown', function escHandler(e) {
                if (e.key === 'Escape') {
                  close();
                  document.removeEventListener('keydown', escHandler);
                } else if (e.key === 'r' || e.key === 'R') {
                  resetView();
                } else if (e.key === '+' || e.key === '=') {
                  scale = Math.min(scale * 1.2, 20);
                  updateTransform();
                } else if (e.key === '-') {
                  scale = Math.max(scale * 0.8, 0.1);
                  updateTransform();
                }
              });
            };

            element.addEventListener('click', maximize);
            expandIcon.addEventListener('click', maximize);
          };

          // Process inline SVGs immediately
          document.querySelectorAll('svg').forEach(wrapElement);

          // Process images - wait for load to get accurate dimensions
          document.querySelectorAll('img').forEach(function(img) {
            if (img.complete) {
              wrapElement(img);
            } else {
              img.addEventListener('load', function() {
                wrapElement(img);
              });
            }
          });
        });
        </script>
    </head>
    <body>
        $for(include-before)$ $include-before$ $endfor$ $if(title)$
        <header id="title-block-header">
            <div class="left">
                <h1 class="title">$title$</h1>
                $if(subtitle)$
                <p class="subtitle">$subtitle$</p>
                $endif$
            </div>
            <div class="right">
                $for(author)$
                <p class="author">$author$</p>
                $endfor$ $if(date)$
                <p class="date">$date$</p>
                $endif$
            </div>
        </header>
        $endif$ $if(toc)$
        <nav id="$idprefix$TOC" role="doc-toc">
            $if(toc-title)$
            <h2 id="$idprefix$toc-title">$toc-title$</h2>
            $endif$ $table-of-contents$
        </nav>
        $endif$ $body$ $for(include-after)$ $include-after$ $endfor$
    </body>
</html>
